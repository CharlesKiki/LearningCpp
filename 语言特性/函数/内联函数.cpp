1 inline内联函数
C++中的const常量可以替代宏常数定义，如：
const int A = 3;  #define A 3
C++中是否有解决方案替代宏代码片段呢？（替代宏代码片段就可以避免宏的副作用！）
C++中推荐使用内联函数替代宏代码片段
C++中使用inline关键字声明内联函数
内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。
//宏替换和函数调用区别
#include "iostream"
using namespace std;
#define MYFUNC(a, b) ((a) < (b) ? (a) : (b))  

inline int myfunc(int a, int b)
{
    return a < b ? a : b;
}

int main()
{
    int a = 1;
    int b = 3;
    //int c = myfunc(++a, b);  //头疼系统
    int c = MYFUNC(++a, b);  

    printf("a = %d\n", a);
    printf("b = %d\n", b);
    printf("c = %d\n", c);

system("pause");
    return 0;
}
说明1：
必须inline int myfunc(int a, int b)和函数体的实现，写在一块
说明2
C++编译器可以将一个函数进行内联编译
被C++编译器内联编译的函数叫做内联函数
内联函数在最终生成的代码中是没有定义的
C++编译器直接将函数体插入在函数调用的地方
内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)
说明3：C++编译器不一定准许函数的内联请求！
说明4
内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）
内联函数是对编译器的一种请求，因此编译器可能拒绝这种请求
内联函数由 编译器处理，直接将编译后的函数体插入调用的地方
宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程
说明5：
现代C++编译器能够进行编译优化，因此一些函数即使没有inline声明，也可能被编译器内联编译
另外，一些现代C++编译器提供了扩展语法，能够对函数进行强制内联
如：g++中的__attribute__((always_inline))属性
说明6：
C++中内联编译的限制：
不能存在任何形式的循环语句    
不能存在过多的条件判断语句
函数体不能过于庞大
不能对函数进行取址操作
函数内联声明必须在调用语句之前
编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。
因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。
结论：
1）内联函数在编译时直接将函数体插入函数调用的地方
2）inline只是一种请求，编译器不一定允许这种请求
3）内联函数省去了普通函数调用时压栈，跳转和返回的开销