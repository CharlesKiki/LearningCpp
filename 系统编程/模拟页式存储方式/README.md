首先，这篇代码的编写风格是面向过程的，根据数据流图来阅读会更容易的理解发生了什么。

# 模拟页式存储管理 #
这个程序的目的是为了模拟内存的初始化，并且简单的访问其中的一个内存单元

 内存单元有主存和辅助储存的概念，实际上凡是主存的内存单元都是在实际的物理内存中的
 而辅助内存是一个假定存在，但是实际上只是在页表中占位的节点
	这里需要注意的是，无论是辅助储存还是实际储存，它们在这个程序中都是定好的。也就是说辅助存储和实际存储适会枯竭的

	please input the size of your process:2048

	page_length is :2
	please input the addresses of the room you want to inqure:
	addresses 1:1024
	
	When input Adddress is 1024
	:
	The current Pagetabke:
	         Pagenumber    Truenumber    Status
	              0             -1           0
	              1             0           1
	The current Frame:
	
	         Truenumber    Pagenum
	              0             1
	              1             0
	              2             0
	addresses 2:

注意，实际上我们模拟的是 The currentFrame区域 使用FIFO方法来让实际的物理内存替换要使用的内存。
	
它要求输入的初始化的进程内存大小，并且要求要访问的内存大小
最后它打印内存单元的信息(根据页表结构头)

这个程序要求输入的地址最终被转化为对应的页码，也就是说，程序命中的查询的是以页为单位的大小，而不是byte的真的地址指针。

在阅读这个代码之前，有一些背景设计规则，
页面尺寸1K，输入进程大小（例如5300bytes），对页表进行初始化
也就是当程序要求输入一个进程大小的时候，默认的输入大小是Kb的大小
内存管理的最小单元是页，也就是1kb的大小。但是输入的值byte单位的。
逻辑处理的是kb

页式存储管理的核心就是表头结构，该结构含有三个关键变量，页号，
物理块号，状态位

物理块号和页号不一定是一一对应的。

当页号是实际上可以存储的时候，它的标志位是True，若果它是不可用的，那么它的状态位是false。

页式存储的实现和C语言库中的malloc方法非常类似。


## 设计思路 ##
页面淘汰算法采用 FIFO页面淘汰算法，并且在淘汰一页时，只将该页在页表中修改状态位。而不再判断它是否被改写过，也不将它写回到辅存。



全局变量的解释

各方法的解释
页式管理的页表结构是如何实现的？

程序是如何实现初始化的？

程序是如何实现访问内存单元的？

程序是如何实现修改内存单元状态的？

内存单元是如何释放一个被占用的内存单元的？


void create_address()；
每访问一个地址(这个地址是物理地址)时，首先要计算该地址所在的页的页号(这是逻辑编号)，
然后查页表，判断该页是否在主存——如果该页已在主存，则打印页表情况；
如果该页不在主存且页框未满（查空闲块表，找到空闲块），则调入该页并修改页表，打印页表情况；
如果该页不在主存且页框已满，则按 FIFO页面淘汰算法淘汰一页后调入所需的页，修改页表，打印页表情况； 

程序执行的逻辑
输入程序的需要的kb大小，按照byte的大小输入
程序返回申请了多少按照kb申请的页式大小

例如5300byte需要6kb的大小来存储(从0开始计数页的数量)

接下来程序询问用户想要访问的内存单元(从1开始，似乎可以不限制的询问所有可用内存地址)

Currnent frame 是什么？实际的物理内存地址嘛？

Pagetable就是逻辑内存的页表

1.实现请求页式的管理，再淘汰一页时，只修改该页在页表中的状态位，不再判断它是否被改写过。

页表初始化：根据输入的进程大小初始化页表。初始化的内容包括：计算页表长度，将状态位置零，物理块号置零。

地址链表建立：将输入的地址流以链表的形式存储，

页面调用：从地址链表的头指针开始调页。调页包括：首先计算所调页面的页号，对于不在内存中的页面使用请求调页策略。

页面置换：对于不在内存中的页面采用先进先出策略进行置换，置换包括：改变页表的状态位，换入请求页面，换出最早调入的页面。




## 对面向过程编程方式的思考 ##

阅读代码的核心在于理解逻辑上程序的运行过程。

往往代码不能单纯的从参数依赖上观察数据的流动，还需要判断那些方法是程序的边界，它们是接受外界系统数据的最外层，辨别这些方法有助于接下来利用参数传递推断程序执行顺序和程序逻辑。

某些方法没有参数，但是内部调用了其他方法。实际上，这些没有参数的方法也可以是程序边界，它们出现在测试用例的初始化中。也就是逻辑上的耦合。这是良好的耦合程度。逻辑上的是分开的。


观察参数的流动虽然能理清一部分的执行顺序，但是如果多个方法都有两个方向上的数据流动方向，这就对程序的内部结构推断产生的困难。


也不能从代码执行的先后推断逻辑上执行的顺序，但是在测试用例中，往往同时出现的几个方法是平级的。也就是说它们都是程序的边界，它们都是接收用户输入的第一个最外层的方法。


数据流图
![enter description here](./images/DataFlow.png)
