这是uOS，适用于单片机（类似51单片机的类型）的任务管理系统。因为单独对系统的一个模块写文档，所以源码中没有注明的变量要先阅读文档。

在讨论任务的优先级调度时，需要了解的是任务的状态有**就绪**和**非就绪状态**。
这些状态被数组类型的数据结构装载，当对任务的优先度变更的时候对这些数据结构进行修改。


在实时操作系统中，**算法时间复杂度为常数**是设计的一部分。
抽象上某个功能要求常数时间内复杂度，这可以体现在承载数据的数据结构被遍历时要求常数时间，比如数组，也可以是一个非数组的数据结构，但是使用与之结构相关系的遍历方法。

为了加快任务控制块的访问速度，ucos还定义了OSTCBPrioTbl[]数组，数组以优先级为顺序存放指向各个任务控制块的指针，这样在访问一个任务的控制块时就可以不必遍历整个控制块链表了

整个程序应该是从面向过程的设计方法的，这就导致了很多调用关系就是直接的文件之间的隔离和链接之后互相的直接调用。所以本质上来说他们是一组函数和变量在自动的基于硬件基础，例如寄存器和定时器，中断等硬件直接交互。

这篇文章讨论的内容是uOS从OS_TASK.C文件中提取的
函数原型INT8U  OSTaskChangePrio (INT8U  oldprio,INT8U  newprio)
该方法主要的操作对象是OSTCBPrioTbl[newprio]数组，该数组以优先级顺序保存了所有任务的访问指针。

函数有两个参数：oldprio和newprio。
返回值为错误码，有五个，分别是
OS_ERR_NONE，新旧优先级对比出错
OS_ERR_PRIO_INVALID，
OS_ERR_PRIO_EXIST，目标优先级已经存在
OS_NO_，ERR正常退出
OS_ERR_PRIO，正在操作的任务不存在

	阅读一个函数方法时，首先注意有几个return返回状态，接受几个参数

并试图解释该方法在系统源码经过编译后在整个系统中处于什么层次，负责了什么，以及触发的场景。

Q:在uOS中谁发出中断令任务优先级更变？

Q:在uOS中是如何保存任务场景并切换其他任务的？

该方法返回值 INT8U 有可能是一种中断调用的返回值。假设触发它的是某个任务的请求，或者来自系统的一种任务优先级安排，导致的中断，让某个实例化的进程优先级改变了。那么调用该方法的应该是操作系统。并且应该存在一个数据结构可以存储每个进程的状态。

变量的定义
 INT8U在os_cpu.h头文件中有定义：
 typedef unsigned char  INT8U; 一个无符号类型的char大小，预计占用1byte的大小。
 
 优先级数组每个下标下保存一个指针类型，每次能获得CPU资源的肯定只有一个指针的任务。也就是说优先级数组实际上也是一个执行的优先级顺序，每次执行优先级为最高的内存，相当于OSTCBPrioTbl[最高优先级]，这就是一个常数时间去寻址。
 	结论:数据流动快，特别是逻辑上执行要求有先后的，需求速度快，使用数组来作为数据结构。